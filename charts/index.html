<!DOCTYPE html>
<!--
    Code adapted from various resource
     - https://codepen.io/freeCodeCamp/pen/KaNGNR
     - https://bl.ocks.org/mjfoster83/7c9bdfd714ab2f2e39dd5c09057a55a0
     - https://bl.ocks.org/mbostock/4063318
     - http://bl.ocks.org/KathyZ/c2d4694c953419e0509b
     - https://bl.ocks.org/mbostock/3884955
-->
<html>
  <head>
    <meta charset="UTF-8">
    <style>
      html *
      {
        font-family: sans-serif;
      }

      h1 {
        font-size: 23px;
        text-align: center;
      }
      h2 {
        font-size: 20px;
        text-align: center;
      }
      h3 {
        font-size: 18px;
        text-align: center;
      }

      img.icon {
        width: 64px;
        text-align:center;
      }

      #info {
        text-align: center;
      }

      div.tooltip {
        position: absolute;
        padding: 10px;
        font-size: 12px;
        background: rgba(255, 255, 204, 0.95);
        box-shadow: 1px 1px 10px rgba(128, 128, 128, 0.6);
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
      }

      svg {
        font: 10px sans-serif;
        text-align: center;
        display: block;
        margin: auto;
      }

      #legend-treemap-commit-files {
        font-size: 15px;
        text-align: center;
        display: block;
        margin: auto;
        padding-bottom: 5px;
        margin-bottom: 2rem;
        margin-top: 1rem;
      }
    </style>
  </head>
  <body>
    <!-- tooltip for charts -->
    <div id="tooltip" class="tooltip" style="opacity:0"></div>

    <!-- info section -->
    <p style="text-align:center"><img id="info_icon" class="icon" src=""></p>
    <div id="info"></div>
    <hr>

    <!-- chart - timeline -->
    <p style="text-align:center"><img class="icon" src="img/map.png"></p>
    <h3>Timeline of Perforce Commits</h3>
    <!-- chart - treemap -->
    <p style="text-align:center"><img class="icon" src="img/tome.png"></p>
    <h3>Summary of Perforce Commits</h3>
    <svg id='treemap-commit-files' width="1024" height="768"></svg>
    <svg id='legend-treemap-commit-files' width="500"></svg>
    <hr>
    <!-- chart - stacked bar -->
    <p style="text-align:center"><img class="icon" src="img/coin.png"></p>
    <h3>Reward</h3>
    <svg id='stackedbar-reward' width="800" height="600"></svg>
    <hr>

    <!-- // -->

    <!-- libs and scripts -->
    <script src="lib/d3.v4.8.0.js"></script>
    <script>

      // generate treemap for commit files counts
      var generate_commit_files_treemap = function(file, options={}) {

        // load data
        d3.json(file, function(error, data){

          if (error) throw error;

          var tooltip = d3.select("#tooltip");

          var svg    = d3.select("#treemap-commit-files"),
              width  = +svg.attr("width"),
              height = +svg.attr("height");

          var fader  = function(color) { return d3.interpolateRgb(color, "#ffffff")(.2); },
              color  = d3.scaleOrdinal(d3.schemeCategory20.map(fader)),
              format = d3.format(",d");

          var treemap = d3.treemap()
                          .size([width, height])
                          .paddingInner(1);

          // options
          const POW_SCALE_COUNT = (options.pow_scale_count === undefined) ? 1 : options.pow_scale_count; // pow scale for data count
          const MAX_DEPTH = (options.max_depth === undefined) ? 7 : options.max_depth; // max depth to show
          const MIN_COUNT = (options.min_count === undefined) ? 2 : options.min_count; // min count to filter out
          const SHOW_TEXT = (options.show_text === undefined) ? true : options.show_text; // min count to filter out

          //// perform data conversion
          // append 'ROOT' ahead, filter out larger depth, and add all possible intermediate dirs
          var data_filtered = {};                          // filtered result       { "ROOT/d1/d2/f1.txt" : 10, "ROOT" : 0, "ROOT/d1" : 0, "ROOT/d1/d2" : 0 }
          for (const path in data) {                       // original commit path  {"//d1/d2/f1.txt" : [4, 3, 2]}
            const commit_count = data[path].length;
            if (commit_count < MIN_COUNT) { continue; }    // ignore file with few comits
            const path_rooted = "ROOT" + path.substr(1);   // append ROOT ahead "//d1/d2/f1.txt"" -> "ROOT/d1/d2/f1.txt" (depth: 0/1/2/3)
            const path_split = path_rooted.split("/");
            const depth_to_process = (path_split.length > MAX_DEPTH ? MAX_DEPTH : path_split.length);
            var idx;
            for (idx = 0; idx < depth_to_process; idx++) {
              const intermediate_dir = path_split.slice(0, idx+1).join("/"); // extract all intermediate dirs
              if (!(intermediate_dir in data_filtered)) {
                data_filtered[ intermediate_dir ] = 0;
              }
            }
            const end_node = path_split.slice(0, idx+1).join("/");           // end node (i.e. MAX_DEPTH)
            if (!(end_node in data_filtered)) {
                data_filtered[ end_node ] = 0;
            }
            data_filtered[ end_node ] += commit_count;                  // number of affected revisions
          }
          // construct treemap data
          var data_treemp = [];                     // conversion result     [ {"id":"ROOT/d1/d2/f1.txt", "value":10, "name":"//d1/d2/f1.txt"}, ... ]
          for (const node in data_filtered) {
            var item = {};
            item.id       = node;
            item.value    = data_filtered[node];
            item.name     = "/" + node.substr(4);    // get back the original path: ROOT/d1/d2/f1.txt -> //d1/d2/f1.txt
            item.category = "Undefined";             // category
            for (const i in options.category) {
              for (const pattern in options.category[i]) {
                const re = new RegExp(pattern);
                if (item.name.match(re)) {
                  item.category = options.category[i][pattern];
                }
              }
            }
            data_treemp.push(item);
          }
          //// end - data conversion

          /// create data and run d3.treemap
          var stratify = d3.stratify()
                           .id(function(d) { return d.id; })
                           .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf("/")); });
          var sum_scale = function(d) { return d.value === 0 ? 0 : Math.pow(d.value, POW_SCALE_COUNT); };
          var root = stratify(data_treemp)
                     .sum(sum_scale)
                     .sort(function(a, b) { return (b.value - a.value   ||
                                                    b.height - a.height ||
                                                    a.data.category.localeCompare(b.data.category)) ||
                                                    a.id.localeCompare(b.id) ||
                                                    0;} );
          treemap(root);
          ///

          var cell = svg.selectAll("g")
                      .data(root.leaves())
                      .enter().append("g")
                        .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; });

          var tile = cell.append("rect")
              .attr("id", function(d) { return "rect-" + d.id; })
              .attr("width", function(d) { return d.x1 - d.x0; })
              .attr("height", function(d) { return d.y1 - d.y0; })
              .attr("fill", function(d) { return color(d.data.category);   })
              .on("mousemove", function(d) {
                tooltip.style("opacity", .9);
                tooltip.html(
                  '' + d.data.name +
                  '<br>Category: ' + d.data.category +
                  '<br>Commits: ' + d.data.value
                )
                .style("left", (d3.event.pageX + 10) + "px")
                .style("top", (d3.event.pageY - 28) + "px");
              })
              .on("mouseout", function(d) {
                tooltip.style("opacity", 0);
              })

          cell.append("clipPath")
            .attr("id", function(d) { return "clip-" + d.id; })
            .append("use")
            .attr("xlink:href", function(d) { return "#rect-" + d.id + ""; });

          cell.append("text")
                .attr("clip-path", function(d) { return "url(#clip-" + d.id + ")"; })
              .append("tspan")
                .attr("x", 4)
                .attr("y", 13)
                .text(function(d) {
                  if (SHOW_TEXT) return d.data.name;
                  else return "";
                });

          var categories = root.leaves().map(function(nodes){
            return nodes.data.category;
          });
          categories = categories.filter(function(category, index, self){
            return self.indexOf(category)===index;
          })
          var legend = d3.select("#legend-treemap-commit-files")
          var legendWidth = +legend.attr("width");
          const LEGEND_OFFSET = 10;
          const LEGEND_RECT_SIZE = 15;
          const LEGEND_H_SPACING = 150;
          const LEGEND_V_SPACING = 10;
          const LEGEND_TEXT_X_OFFSET = 3;
          const LEGEND_TEXT_Y_OFFSET = -2;
          var legendElemsPerRow = Math.floor(legendWidth/LEGEND_H_SPACING);

          var legendElem = legend
            .append("g")
            .attr("transform", "translate(60," + LEGEND_OFFSET + ")")
            .selectAll("g")
            .data(categories)
            .enter().append("g")
            .attr("transform", function(d, i) {
              return 'translate(' +
              ((i%legendElemsPerRow)*LEGEND_H_SPACING) + ',' +
              ((Math.floor(i/legendElemsPerRow))*LEGEND_RECT_SIZE + (LEGEND_V_SPACING*(Math.floor(i/legendElemsPerRow)))) + ')';
            })

          legendElem.append("rect")
            .attr('width', LEGEND_RECT_SIZE)
            .attr('height', LEGEND_RECT_SIZE)
            .attr('fill', function(d){
              return color(d);
            })

          legendElem.append("text")
            .attr('x', LEGEND_RECT_SIZE + LEGEND_TEXT_X_OFFSET)
            .attr('y', LEGEND_RECT_SIZE + LEGEND_TEXT_Y_OFFSET)
            .text(function(d) { return d; });
        });
      };
      // end - generate_commit_files_treemap

      // generate reward stacked chart
      var generate_reward_stacked_chart = function(file, options={}) {

        var tooltip = d3.select("#tooltip");

        // create the svg
        var svg = d3.select("#stackedbar-reward"),
            margin = {top: 20, right: 20, bottom: 40, left: 40},
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom,
            g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // set x scale
        var x = d3.scaleBand()
            .rangeRound([0, width])
            .paddingInner(0.05)
            .align(0.1);

        // set y scale
        var y = d3.scaleLinear()
            .rangeRound([height, 0]);

        // set the colors
        const colors = (options.colors === undefined) ? ["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"] : options.colors;
        var z = d3.scaleOrdinal()
            .range(colors);

        d3.csv(file, function(error, data) {
          if (error) throw error;

          // reconstruct data
          var data_filtered = {};  // according to year
          var org_filtered  = {};  // according to org
          for (var i = 0; i < data.length; i++) {
             const yr     = +data[i]["Year"];
             const months = +data[i]["Month"];
             const brutto = +data[i]["AnnualBrutto"];
             const org    =  data[i]["Org"];
             org_filtered[org] = 1;
             if (!(yr in data_filtered)) {
              data_filtered[yr] = {};
              data_filtered[yr]["Year"] = yr;
              data_filtered[yr]["Month"] = {};
              data_filtered[yr]["Month"][org] = months;
              data_filtered[yr][org] = brutto;
              data_filtered[yr]["Total"] = brutto;
             }
             else {
              data_filtered[yr]["Month"][org] = months;
              data_filtered[yr][org] = brutto;
              data_filtered[yr]["Total"] += brutto;
             }
          }
          for (const yr in data_filtered) {
            for (const org in org_filtered) {
              if (!(org in data_filtered[yr])) {
                data_filtered[yr][org] = 0;
              }
            }
          }
          // end of data reconstruction

          // prepare data for d3.stack
          const keys = Object.keys(org_filtered);
          var data_stack = [];
          for (const yr in data_filtered) {
            data_stack.push(data_filtered[yr]);
          }
          data_stack.sort(function(a, b) { return a.Year - b.Year; });
          x.domain(data_stack.map(function(d) { return d.Year; }));
          y.domain([0, d3.max(data_stack, function(d) { return d.Total; })]).nice();
          z.domain(keys);

          g.append("g")
            .selectAll("g")
            .data(d3.stack().keys(keys)(data_stack))
            .enter().append("g")
              .attr("fill", function(d) { return z(d.key); })
              .attr("opacity", 0.8)
            .selectAll("rect")
            .data(function(d) { return d; })
            .enter().append("rect")
              .attr("x", function(d) { return x(d.data.Year); })
              .attr("y", function(d) { return y(d[1]); })
              .attr("height", function(d) { return y(d[0]) - y(d[1]); })
              .attr("width", x.bandwidth())
            .on("mousemove", function(d) {
                  var str = "";
                  var count = 0;
                  for (const i in keys) {
                    const org = keys[i];
                    if (d.data[org] > 0) {
                      str += org + ': &euro; '  + d.data[org] + ' (' + d.data.Month[org] + ' months) <br>';
                      count++;
                    }
                  }
                  if (count > 1) {
                    str = str + '<br>Total: &euro; ' + d.data.Total;
                  }


                  tooltip.style("opacity", .9);
                  tooltip.html(
                    str
                  )
                  .style("left", (d3.event.pageX + 10) + "px")
                  .style("top", (d3.event.pageY - 28) + "px");
            })
            .on("mouseout", function(d) {
                   tooltip.style("opacity", 0);
            });

          g.append("g")
              .attr("class", "axis")
              .attr("transform", "translate(0," + height + ")")
              .call(d3.axisBottom(x));

          g.append("g")
              .attr("class", "axis")
              .call(d3.axisLeft(y).ticks(null, "s"))
            .append("text")
              .attr("x", 2)
              .attr("y", y(y.ticks().pop()) + 0.5)
              .attr("dy", "0.32em")
              .attr("fill", "#000")
              .attr("font-weight", "bold")
              .attr("text-anchor", "start");

        });
      }
      // end - generate_reward_stacked_chart

      // generate all charts
      var generate_charts = function(config) {
        // info icon
        d3.select("#info_icon").attr("src", config.info.gender.match(/^m/) ? "img/head_m.jpg" : "img/head_f.jpg");
        // info
        var info = d3.select("#info");
        info.append("h2")
            .text(config.info.name);
        // charts
        generate_commit_files_treemap(config.data.commit_files_json, config.options.commit_file_treemap);
        generate_reward_stacked_chart(config.data.monetary_csv, config.options.reward_stacked_chart);
      };

      // __MAIN__

      // load private config if possible
      d3.json("private.config.json", function(error, config) {
        if (error) {
          console.log("Failed to read private.config.json. The default config.json will be used.");
          // or load public config
          d3.json("config.json", function(error, config) {
            if (error) throw error;
            generate_charts(config);
          });
        }
        else {
          generate_charts(config);
        }
      });
    </script>
  </body>
