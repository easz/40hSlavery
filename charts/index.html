<!DOCTYPE html>
<html>
  <!-- Code adapted from https://codepen.io/freeCodeCamp/pen/KaNGNR -->
  <head>
    <meta charset="UTF-8">
    <style>
      html *
      {
        font-family: sans-serif;
      }

      h1 {
        font: 23px;
        text-align: center;
      }
      svg {
        font: 10px sans-serif;
        text-align: center;
        display: block;
        margin: auto;
      }

      div.tooltip {
        position: absolute;
        padding: 10px;
        font: 12px Arial;
        background: rgba(255, 255, 204, 0.95);
        box-shadow: 1px 1px 10px rgba(128, 128, 128, 0.6);
        border: 0px;
        border-radius: 2px;
        pointer-events: none;
      }

      #legend{
        font-size: 15px;
        text-align: center;
        display: block;
        margin: auto;
        padding-bottom: 5px;
        margin-bottom: 2rem;
        margin-top: 1rem;
      }
    </style>
  </head>
  <body>
    <h1>Report</h1>
    <!-- chart containers -->
    <svg id='tree-map-commit-files' width="960" height="570"></svg>
    <svg id='legend-tree-map-commit-files' width="500"></svg>

    <!-- libs -->
    <script src="lib/d3.v4.8.0.js"></script>

    <script>

      // generate treemap for commit files counts
      var generate_commit_files_treemap = function(file, options={}) {

        // load data
        d3.json(file, function(error, data){

          if (error) throw error;

          var body = d3.select("body");

          var tooltip = body.append("div")
                            .attr("class", "tooltip")
                            .attr("id", "tooltip")
                            .style("opacity", 0);

          var svg   = d3.select("#tree-map-commit-files"),
              width  = +svg.attr("width"),
              height = +svg.attr("height");

          var fader  = function(color) { return d3.interpolateRgb(color, "#ffffff")(.2); },
              color  = d3.scaleOrdinal(d3.schemeCategory20.map(fader)),
              format = d3.format(",d");

          var treemap = d3.treemap()
                          .size([width, height])
                          .paddingInner(1);

          // options
          const POW_SCALE_COUNT = (options.pow_scale_count === undefined) ? 1 : options.pow_scale_count; // pow scale for data count
          const MAX_DEPTH = (options.max_depth === undefined) ? 7 : options.max_depth; // max depth to show
          const MIN_COUNT = (options.min_count === undefined) ? 2 : options.min_count; // min count to filter out

          //// perform data conversion
          // append 'ROOT' ahead, filter out larger depth, and add all possible intermediate dirs
          var data_filtered = {};                          // filtered result       { "ROOT/d1/d2/f1.txt" : 10, "ROOT" : 0, "ROOT/d1" : 0, "ROOT/d1/d2" : 0 }
          for (const path in data) {                       // original commit path  {"//d1/d2/f1.txt" : [4, 3, 2]}
            const commit_count = data[path].length;
            if (commit_count < MIN_COUNT) { continue; }    // ignore file with few comits
            const path_rooted = "ROOT" + path.substr(1);   // append ROOT ahead "//d1/d2/f1.txt"" -> "ROOT/d1/d2/f1.txt" (depth: 0/1/2/3)
            const path_split = path_rooted.split("/");
            const depth_to_process = (path_split.length > MAX_DEPTH ? MAX_DEPTH : path_split.length);
            var idx;
            for (idx = 0; idx < depth_to_process; idx++) {
              const intermediate_dir = path_split.slice(0, idx+1).join("/"); // extract all intermediate dirs
              if (!(intermediate_dir in data_filtered)) {
                data_filtered[ intermediate_dir ] = 0;
              }
            }
            const end_node = path_split.slice(0, idx+1).join("/");           // end node (i.e. MAX_DEPTH)
            if (!(end_node in data_filtered)) {
                data_filtered[ end_node ] = 0;
            }
            data_filtered[ end_node ] += commit_count;                  // number of affected revisions
          }
          // construct treemap data
          var data_treemp = [];                     // conversion result     [ {"id":"ROOT/d1/d2/f1.txt", "value":10, "name":"//d1/d2/f1.txt"}, ... ]
          for (const node in data_filtered) {
            var item = {};
            item.id       = node;
            item.value    = data_filtered[node];
            item.name     = "/" + node.substr(4);    // get back the original path: ROOT/d1/d2/f1.txt -> //d1/d2/f1.txt
            item.category = "Undefined";             // category
            for (const i in options.category) {
              for (const pattern in options.category[i]) {
                const re = new RegExp(pattern);
                if (item.name.match(re)) {
                  item.category = options.category[i][pattern];
                }
              }
            }
            data_treemp.push(item);
          }
          //// end - data conversion

          /// create data and run d3.treemap
          var stratify = d3.stratify()
                           .id(function(d) { return d.id; })
                           .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf("/")); });
          var sum_scale = function(d) { return d.value === 0 ? 0 : Math.pow(d.value, POW_SCALE_COUNT); };
          var root = stratify(data_treemp)
                     .sum(sum_scale)
                     .sort(function(a, b) { return (b.value - a.value   ||
                                                    b.height - a.height ||
                                                    a.data.category.localeCompare(b.data.category)) ||
                                                    a.id.localeCompare(b.id) ||
                                                    0;} );
          treemap(root);
          ///

          var cell = svg.selectAll("g")
              .data(root.leaves())
              .enter().append("g")
              .attr("class", "group")
              .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; });

          var tile = cell.append("rect")
              .attr("id", function(d) { return d.data.id; })
              .attr("class", "tile")
              .attr("width", function(d) { return d.x1 - d.x0; })
              .attr("height", function(d) { return d.y1 - d.y0; })
              .attr("data-name", function(d){
                return d.data.name;
              })
              .attr("data-category", function(d){
                return d.data.category;
              })
              .attr("data-value", function(d){
                return d.data.value;
              })
              .attr("fill", function(d) {
                return color(d.data.category);
              })
              .on("mousemove", function(d) {
                tooltip.style("opacity", .9);
                tooltip.html(
                  '' + d.data.name +
                  '<br>Category: ' + d.data.category +
                  '<br>File Commits: ' + d.data.value
                )
                .attr("data-value", d.data.value)
                .style("left", (d3.event.pageX + 10) + "px")
                .style("top", (d3.event.pageY - 28) + "px");
              })
              .on("mouseout", function(d) {
                tooltip.style("opacity", 0);
              })

          cell.append("text")
            .attr('class', 'tile-text')
            .selectAll("tspan")
            .data(function(d) { return d.data.name.split(/(?=[A-Z][^A-Z])/g); })
            .enter().append("tspan")
            .attr("x", 4)
            .attr("y", function(d, i) { return 13 + i * 10; })
            .text(function(d) { return d; });

          var categories = root.leaves().map(function(nodes){
            return nodes.data.category;
          });
          categories = categories.filter(function(category, index, self){
            return self.indexOf(category)===index;
          })
          var legend = d3.select("#legend-tree-map-commit-files")
          var legendWidth = +legend.attr("width");
          const LEGEND_OFFSET = 10;
          const LEGEND_RECT_SIZE = 15;
          const LEGEND_H_SPACING = 150;
          const LEGEND_V_SPACING = 10;
          const LEGEND_TEXT_X_OFFSET = 3;
          const LEGEND_TEXT_Y_OFFSET = -2;
          var legendElemsPerRow = Math.floor(legendWidth/LEGEND_H_SPACING);

          var legendElem = legend
            .append("g")
            .attr("transform", "translate(60," + LEGEND_OFFSET + ")")
            .selectAll("g")
            .data(categories)
            .enter().append("g")
            .attr("transform", function(d, i) {
              return 'translate(' +
              ((i%legendElemsPerRow)*LEGEND_H_SPACING) + ',' +
              ((Math.floor(i/legendElemsPerRow))*LEGEND_RECT_SIZE + (LEGEND_V_SPACING*(Math.floor(i/legendElemsPerRow)))) + ')';
            })

          legendElem.append("rect")
            .attr('width', LEGEND_RECT_SIZE)
            .attr('height', LEGEND_RECT_SIZE)
            .attr('class','legend-item')
            .attr('fill', function(d){
              return color(d);
            })

          legendElem.append("text")
            .attr('x', LEGEND_RECT_SIZE + LEGEND_TEXT_X_OFFSET)
            .attr('y', LEGEND_RECT_SIZE + LEGEND_TEXT_Y_OFFSET)
            .text(function(d) { return d; });
        });
      };
      // end - generate_commit_files_treemap

      // generate all charts
      var generate_charts = function(data) {
        generate_commit_files_treemap(data.commit_files_json, data.options.commit_file_treemap);
      };

      // __MAIN__
      // load private config
      d3.json("private.config.json", function(error, data) {
        if (error) {
          // or load public config
          d3.json("config.json", function(error, data) {
            if (error) throw error;
            generate_charts(data);
          });
        }
        else {
          generate_charts(data);
        }
      });

    </script>
  </body>
